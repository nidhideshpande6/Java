Understanding Strings and Immutability in Java

This document explores the advanced concepts of immutability, mutability, and their implications in Java, focusing on Strings, StringBuilder, StringBuffer, and designing immutable classes. The content is tailored for professionals with 2 years of experience and includes interview-level insights.

## 1. Creating String Objects

Strings in Java can be created using:

- String Literals: Stored in the String Pool.

- new Keyword: Creates a new object in the heap memory.

Example:
```java
public class Main {
    public static void main(String[] args) {
        String literalString = "Hello"; // String literal
        String newString = new String("Hello"); // Using new keyword

        System.out.println(literalString == newString); // false
        System.out.println(literalString.equals(newString)); // true
    }
}
```
Key Points:

String literals are stored in a shared pool to optimize memory.

Strings created with new are stored in the heap and are not interned unless explicitly done using intern().

## 2. Strings are Immutable

String immutability ensures thread safety and security. Once created, a String object cannot be modified.

Example:
```java
public class Main {
    public static void main(String[] args) {
        String s1 = "Java";
        s1.concat(" Programming");
        System.out.println(s1); // Output: Java

        String s2 = s1.concat(" Programming");
        System.out.println(s2); // Output: Java Programming
    }
}
```
Key Points:

Operations like concat or replace return a new object, leaving the original String unchanged.

## 3. StringBuffer and StringBuilder

Unlike String, StringBuffer and StringBuilder are mutable.

Differences:

- StringBuffer: Thread-safe but slower.

- StringBuilder: Not thread-safe but faster.

Example:
```java
public class Main {
    public static void main(String[] args) {
        StringBuffer buffer = new StringBuffer("Hello");
        buffer.append(" World");
        System.out.println(buffer); // Output: Hello World

        StringBuilder builder = new StringBuilder("Hello");
        builder.append(" Java");
        System.out.println(builder); // Output: Hello Java
    }
}
```
Key Points:

Use StringBuffer for multithreaded environments.

Use StringBuilder for single-threaded environments for better performance.

## 4. Creating an Immutable Class

To create an immutable class, ensure:

Declare the class as final.

Make fields private and final.

Provide getters without setters.

Use defensive copying for mutable fields.

Example:
```java
import java.util.Date;

public final class ImmutablePerson {
    private final String name;
    private final Date birthDate;

    public ImmutablePerson(String name, Date birthDate) {
        this.name = name;
        this.birthDate = new Date(birthDate.getTime()); // Defensive copy
    }

    public String getName() {
        return name;
    }

    public Date getBirthDate() {
        return new Date(birthDate.getTime()); // Defensive copy
    }
}

class Main {
    public static void main(String[] args) {
        ImmutablePerson person = new ImmutablePerson("Alice", new Date());
        System.out.println(person.getName());
        System.out.println(person.getBirthDate());
    }
}
```
Key Points:

Defensive copying prevents external modifications to mutable fields.

## 5. Avoid Modifying Date Objects

To maintain immutability while using Date, always return a defensive copy.

Example:
```java
import java.util.Date;

public class Main {
    public static void main(String[] args) {
        Date birthDate = new Date();
        ImmutablePerson person = new ImmutablePerson("Bob", birthDate);

        birthDate.setTime(0); // Attempt to modify
        System.out.println(person.getBirthDate()); // Original date remains unchanged
    }
}
```
Key Points:

Returning a new Date instance protects the internal state of the object.

## 6. Handling Mutability in Java Objects

Mutable objects can lead to unintended side effects if shared between classes. Defensive copying and encapsulation are essential for safe operations.

Example:
```java
import java.util.ArrayList;
import java.util.Collections;
import java.util.List;

public class Company {
    private final List<String> employees;

    public Company(List<String> employees) {
        this.employees = new ArrayList<>(employees); // Defensive copy
    }

    public List<String> getEmployees() {
        return Collections.unmodifiableList(employees); // Unmodifiable view
    }
}

class Main {
    public static void main(String[] args) {
        List<String> employeeList = new ArrayList<>();
        employeeList.add("John");
        employeeList.add("Jane");

        Company company = new Company(employeeList);
        employeeList.add("Mark"); // Attempt to modify original list

        System.out.println(company.getEmployees()); // [John, Jane]
    }
}
```
Key Points:

Always provide an unmodifiable view for collections.

Encapsulate mutable objects to avoid external modifications.

This document highlights nuanced aspects of immutability and mutability in Java. Let me know if you need additional examples or refinements.


Advanced Java Topics

This document explores advanced Java concepts, tailored for professionals with 2 years of experience. It includes practical examples and interview-focused insights on cloning, collections, marker interfaces, and generics.

## 1. Using the clone Method to Create a Separate Copy of an Object

The clone method in Java creates a shallow copy of an object. To enable cloning, a class must implement the Cloneable interface and override the clone method.

Example:
```java
class Employee implements Cloneable {
    private String name;
    private int id;

    public Employee(String name, int id) {
        this.name = name;
        this.id = id;
    }

    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }

    @Override
    public String toString() {
        return "Employee{name='" + name + "', id=" + id + "}";
    }
}

public class Main {
    public static void main(String[] args) throws CloneNotSupportedException {
        Employee emp1 = new Employee("Alice", 101);
        Employee emp2 = (Employee) emp1.clone();

        System.out.println(emp1);
        System.out.println(emp2);
    }
}
```
Key Points:

Shallow copying does not duplicate objects referenced by fields; only the references are copied.

For deep cloning, you must manually clone nested objects.

## 2. Storing Passwords in a char[] Instead of String

String objects are immutable, which means their contents cannot be modified. Passwords stored in String remain in memory until garbage collected, potentially exposing them to memory dumps.

Example:
```java
import java.util.Arrays;

public class Main {
    public static void main(String[] args) {
        char[] password = {'p', 'a', 's', 's', 'w', 'o', 'r', 'd'};
        System.out.println("Password: " + Arrays.toString(password));

        // Clear the password
        Arrays.fill(password, '*');
        System.out.println("Cleared Password: " + Arrays.toString(password));
    }
}
```
Key Points:

Use char[] for storing passwords to overwrite the data after use.

## 3. Writing Custom Marker Interfaces in Java

A marker interface has no methods and is used to indicate a specific capability or behavior.

Example:
```java
interface Secure {} // Marker Interface

class Document implements Secure {
    private String content;

    public Document(String content) {
        this.content = content;
    }

    public void display() {
        System.out.println("Secure Document: " + content);
    }
}

public class Main {
    public static void main(String[] args) {
        Document doc = new Document("Confidential Info");
        if (doc instanceof Secure) {
            doc.display();
        } else {
            System.out.println("Document is not secure.");
        }
    }
}
```
Key Points:

Marker interfaces can signal behavior to runtime or frameworks.

## 4. Difference Between ArrayList and LinkedList

- ArrayList:

  - Stores elements in a dynamic array.

  - Fast for random access but slow for insertions/deletions in the middle.

- LinkedList:

  - Stores elements in a doubly-linked list.

  - Efficient for frequent insertions/deletions.

Example:
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        List<String> arrayList = new ArrayList<>();
        List<String> linkedList = new LinkedList<>();

        arrayList.add("Alice");
        linkedList.add("Alice");

        System.out.println("ArrayList: " + arrayList);
        System.out.println("LinkedList: " + linkedList);
    }
}
```
Key Points:

Choose based on use case: frequent updates (LinkedList) vs frequent reads (ArrayList).

## 5. Using Generics with Lists to Avoid Type Casting

Generics enforce compile-time type safety and eliminate the need for explicit casting.

Example:
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        List<Integer> numbers = new ArrayList<>();
        numbers.add(10);
        numbers.add(20);

        for (int number : numbers) {
            System.out.println(number);
        }
    }
}
```
Key Points:

Generics prevent runtime errors by ensuring type safety at compile time.

## 6. Creating a Custom ArrayList to Disallow Duplicates

You can extend ArrayList to customize its behavior.

Example:
```java
import java.util.*;

class NoDuplicatesArrayList<E> extends ArrayList<E> {
    @Override
    public boolean add(E e) {
        if (!this.contains(e)) {
            return super.add(e);
        }
        return false;
    }
}

public class Main {
    public static void main(String[] args) {
        List<String> list = new NoDuplicatesArrayList<>();
        list.add("Alice");
        list.add("Bob");
        list.add("Alice");

        System.out.println(list); // Output: [Alice, Bob]
    }
}
```
Key Points:

Override methods to customize ArrayList behavior.

## 7. Set Implementation and Duplicate Objects

If equals and hashCode are not overridden, custom objects can bypass Set's uniqueness.

Example:
```java
import java.util.*;

class Employee {
    private String name;
    private int id;

    public Employee(String name, int id) {
        this.name = name;
        this.id = id;
    }

    @Override
    public String toString() {
        return "Employee{name='" + name + "', id=" + id + "}";
    }
}

public class Main {
    public static void main(String[] args) {
        Set<Employee> employees = new HashSet<>();
        employees.add(new Employee("Alice", 101));
        employees.add(new Employee("Alice", 101));

        System.out.println(employees.size()); // Output: 2
    }
}
```
Correct Implementation:
```java
@Override
public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null || getClass() != obj.getClass()) return false;
    Employee employee = (Employee) obj;
    return id == employee.id && Objects.equals(name, employee.name);
}

@Override
public int hashCode() {
    return Objects.hash(name, id);
}
```
Key Points:

Always override equals and hashCode when using custom objects in a Set.

This document provides a comprehensive overview of advanced topics related to cloning, collections, and generics. Let me know if more details are needed!


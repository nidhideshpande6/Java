## Advanced Java Concepts for Professionals

#### This document covers advanced concepts related to collections, exceptions, and proper coding practices, focusing on tricky scenarios and interview-level insights for professionals with 2 years of experience.

## 1. Proper Implementation of equals and hashCode

Properly implementing equals and hashCode is crucial to avoid duplicates in collections like HashSet or ensuring correct behavior in HashMap.

### Key Rules for Implementation:

- Consistency: If two objects are equal, they must have the same hash code.

- Non-nullity: The equals method should return false if the argument is null.

- Reflexive, Symmetric, Transitive, Consistent: These properties must be adhered to.

### Advanced Example:
```java
import java.util.Objects;

class Employee {
    private int id;
    private String name;

    public Employee(int id, String name) {
        this.id = id;
        this.name = name;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        Employee employee = (Employee) o;
        return id == employee.id && Objects.equals(name, employee.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id, name);
    }
}

public class Main {
    public static void main(String[] args) {
        Set<Employee> employees = new HashSet<>();
        employees.add(new Employee(1, "Alice"));
        employees.add(new Employee(1, "Alice"));
        System.out.println(employees.size()); // Output: 1
    }
}
```
Key Points:

Use Objects.hash to simplify hashCode implementation.

Always override both methods together.

## 2. Compile-Time Exceptions

Compile-time exceptions, also known as checked exceptions, must be handled during compilation using a try-catch block or declared in the method signature with throws.

Advanced Example:
```java
import java.io.IOException;

class Main {
    public static void main(String[] args) {
        try {
            readFile("example.txt");
        } catch (IOException e) {
            System.out.println("Handled IOException: " + e.getMessage());
        }
    }

    public static void readFile(String fileName) throws IOException {
        if (fileName == null) {
            throw new IOException("File name cannot be null");
        }
        System.out.println("Reading file: " + fileName);
    }
}
```
Key Points:

Checked exceptions are enforced at compile time.

Helps in ensuring robust error handling.

### 3. FileNotFoundException is a Checked Exception

FileNotFoundException is a subclass of IOException and is checked, meaning it must be explicitly handled or declared.

Advanced Example:
```java
import java.io.File;
import java.io.FileNotFoundException;
import java.util.Scanner;

public class Main {
    public static void main(String[] args) {
        try {
            readFile("nonexistent.txt");
        } catch (FileNotFoundException e) {
            System.out.println("File not found: " + e.getMessage());
        }
    }

    public static void readFile(String fileName) throws FileNotFoundException {
        File file = new File(fileName);
        Scanner scanner = new Scanner(file);
        while (scanner.hasNextLine()) {
            System.out.println(scanner.nextLine());
        }
    }
}
```
Key Points:

Always validate file existence before attempting to read it.

A try-with-resources block can be used for automatic resource management.

### 4. Delegating Exception Handling

Delegating exceptions to the caller allows for centralized error handling.

Advanced Example:
```java
public class Main {
    public static void main(String[] args) {
        try {
            performCalculation();
        } catch (ArithmeticException e) {
            System.out.println("Error: " + e.getMessage());
        }
    }

    public static void performCalculation() {
        divide(10, 0);
    }

    public static void divide(int a, int b) {
        if (b == 0) {
            throw new ArithmeticException("Division by zero");
        }
        System.out.println(a / b);
    }
}
```
Key Points:

Delegate exceptions to higher-level methods for better code readability and maintainability.

Avoid handling exceptions prematurely when it makes sense to propagate them.

### 5. Exception Hierarchy

Understanding the order of exception hierarchy ensures proper handling. Specific exceptions should always precede generic ones in a try-catch block.

Advanced Example:
```java
public class Main {
    public static void main(String[] args) {
        try {
            int[] arr = new int[5];
            System.out.println(arr[10]); // Throws ArrayIndexOutOfBoundsException
        } catch (ArrayIndexOutOfBoundsException e) {
            System.out.println("Caught specific exception: " + e.getMessage());
        } catch (Exception e) {
            System.out.println("Caught generic exception: " + e.getMessage());
        }
    }
}
```
Key Points:

Catch specific exceptions first to handle known issues effectively.

The Exception block acts as a fallback for unanticipated errors.

### 6. Stopping the finally Block from Execution

The finally block executes in almost all scenarios, but certain actions can prevent it.

Advanced Example:
```java
public class Main {
    public static void main(String[] args) {
        try {
            System.exit(0); // Terminates JVM
        } finally {
            System.out.println("This won't execute.");
        }
    }
}
```
Key Points:

JVM termination using System.exit prevents the finally block from executing.

Avoid using System.exit in production-grade applications.

This document addresses nuanced and tricky parts of Java programming relevant for experienced professionals. Let me know if you'd like to add more scenarios or refine these examples further.


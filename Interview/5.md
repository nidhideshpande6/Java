Advanced Java Topics: Sorting and Iterators

This document covers essential Java concepts, including the relationship between equals and hashCode, sorting with Comparable and Comparator, custom sorting techniques, and the difference between fail-fast and fail-safe iterators.

## 1. The Contract Between equals and hashCode

In Java, the equals and hashCode methods must follow a strict contract to ensure correct behavior in collections like HashSet and HashMap.

Key Rules:

- If two objects are equal according to equals, they must have the same hash code.

- If two objects have the same hash code, they may or may not be equal.

For consistent behavior, both methods should be overridden together.

Example:
```java
import java.util.*;

class Employee {
    private String name;
    private int id;

    public Employee(String name, int id) {
        this.name = name;
        this.id = id;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj) return true;
        if (obj == null || getClass() != obj.getClass()) return false;
        Employee employee = (Employee) obj;
        return id == employee.id && Objects.equals(name, employee.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, id);
    }

    @Override
    public String toString() {
        return "Employee{name='" + name + "', id=" + id + "}";
    }
}

public class Main {
    public static void main(String[] args) {
        Set<Employee> employees = new HashSet<>();
        employees.add(new Employee("Alice", 101));
        employees.add(new Employee("Alice", 101));

        System.out.println(employees); // Only one object is retained
    }
}
```
## 2. Sorting Objects Using Comparable and Comparator

Using Comparable:

The Comparable interface is used for natural ordering of objects.

Example:
```java
import java.util.*;

class Employee implements Comparable<Employee> {
    private String name;
    private int id;

    public Employee(String name, int id) {
        this.name = name;
        this.id = id;
    }

    @Override
    public int compareTo(Employee other) {
        return Integer.compare(this.id, other.id);
    }

    @Override
    public String toString() {
        return "Employee{name='" + name + "', id=" + id + "}";
    }
}

public class Main {
    public static void main(String[] args) {
        List<Employee> employees = Arrays.asList(
            new Employee("Alice", 102),
            new Employee("Bob", 101),
            new Employee("Charlie", 103)
        );
        Collections.sort(employees);
        System.out.println(employees); // Sorted by ID
    }
}
```
Using Comparator:

The Comparator interface allows custom sorting.

Example:
```java
import java.util.*;

class Employee {
    private String name;
    private int id;

    public Employee(String name, int id) {
        this.name = name;
        this.id = id;
    }

    @Override
    public String toString() {
        return "Employee{name='" + name + "', id=" + id + "}";
    }
}

class NameComparator implements Comparator<Employee> {
    @Override
    public int compare(Employee e1, Employee e2) {
        return e1.name.compareTo(e2.name);
    }
}

public class Main {
    public static void main(String[] args) {
        List<Employee> employees = Arrays.asList(
            new Employee("Alice", 102),
            new Employee("Charlie", 103),
            new Employee("Bob", 101)
        );
        Collections.sort(employees, new NameComparator());
        System.out.println(employees); // Sorted by name
    }
}
```
## 3. Custom Sorting Using Comparator

Custom sorting allows sorting by multiple attributes or complex logic.

Example:

Sorting by ID and name:
```java
Collections.sort(employees, (e1, e2) -> {
    int idComparison = Integer.compare(e1.id, e2.id);
    return idComparison != 0 ? idComparison : e1.name.compareTo(e2.name);
});
```
Key Points:

Lambda expressions simplify custom comparators.

Use Comparator.comparing() for more concise code.

## 4. Fail-Fast and Fail-Safe Iterators

Fail-Fast Iterators:

Immediately throw ConcurrentModificationException if the collection is modified during iteration.

Example: ArrayList, HashSet, and HashMap.

Example:
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        List<String> list = new ArrayList<>(Arrays.asList("A", "B", "C"));

        for (String item : list) {
            list.add("D"); // Throws ConcurrentModificationException
        }
    }
}
```
Fail-Safe Iterators:

Allow modification of the collection during iteration.

Example: CopyOnWriteArrayList, ConcurrentHashMap.

Example:
```java
import java.util.concurrent.*;

public class Main {
    public static void main(String[] args) {
        CopyOnWriteArrayList<String> list = new CopyOnWriteArrayList<>(Arrays.asList("A", "B", "C"));

        for (String item : list) {
            list.add("D"); // No exception thrown
        }

        System.out.println(list); // Output: [A, B, C, D]
    }
}
```
Key Points:

Prefer fail-safe iterators for concurrent applications.

Fail-fast iterators are faster due to minimal overhead.

This document provides a detailed look into sorting mechanisms and iterator behavior in Java, essential for handling collections efficiently and safely. Let me know if additional examples or topics are required!


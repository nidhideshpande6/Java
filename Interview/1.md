# Advanced OOP Concepts in Java for Professionals

This document provides an in-depth explanation of OOP concepts tailored for a 2-year experienced professional, focusing on interview-level details and nuances.

## 1. Pillars of OOP Concepts

### Encapsulation
Encapsulation ensures that a class's internal representation is hidden from the outside world and accessed only through well-defined interfaces. This is achieved by:

- Declaring class variables as `private`.
- Providing `public` getter and setter methods to access and modify the data.

#### Advanced Example:
**Thread-Safe Encapsulation**
```java
class Account {
    private String accountNumber;
    private double balance;

    public Account(String accountNumber, double balance) {
        this.accountNumber = accountNumber;
        this.balance = balance;
    }

    public synchronized void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
        }
    }

    public synchronized void withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
        } else {
            throw new IllegalArgumentException("Insufficient balance.");
        }
    }

    public synchronized double getBalance() {
        return balance;
    }
}
```
**Key Points:**
- Use `synchronized` to ensure thread safety.
- Handle edge cases (e.g., overdrafts) explicitly.

### Inheritance
Inheritance allows for extending the functionality of a base class while maintaining its structure. However, in professional settings, excessive inheritance can lead to fragility (tight coupling).

#### Advanced Example:
**Using `final` to Prevent Inheritance**
```java
class Base {
    public final void show() {
        System.out.println("Base class method.");
    }
}

class Derived extends Base {
    // Compilation error if trying to override show()
}
```
**Key Points:**
- Mark methods `final` to prevent overriding.
- Prefer composition over inheritance when applicable.

### Polymorphism
Polymorphism enables the ability to define one interface but have multiple implementations.

#### Advanced Example:
**Covariant Return Types**
```java
class Parent {
    Parent getInstance() {
        return new Parent();
    }
}

class Child extends Parent {
    @Override
    Child getInstance() {
        return new Child();
    }
}
```
**Key Points:**
- Covariant return types allow overriding methods to return a subclass of the declared return type in the parent class.

### Abstraction
Abstraction focuses on exposing only essential details to the user while hiding implementation details. It is often implemented using interfaces and abstract classes.

#### Advanced Example:
**Multiple Inheritance with Interfaces**
```java
interface A {
    default void display() {
        System.out.println("Interface A");
    }
}

interface B {
    default void display() {
        System.out.println("Interface B");
    }
}

class C implements A, B {
    @Override
    public void display() {
        A.super.display(); // Resolving ambiguity
        B.super.display();
    }
}
```
**Key Points:**
- Interfaces can include default methods to provide base functionality.
- Use `super` to resolve ambiguity in multiple inheritance scenarios.

## 2. Dynamic Polymorphism
Dynamic polymorphism, or method overriding, allows runtime determination of the method to execute.

#### Advanced Example:
**Double Dispatch Using Polymorphism**
```java
abstract class Animal {
    abstract void makeSound();
}

class Dog extends Animal {
    @Override
    void makeSound() {
        System.out.println("Bark");
    }
}

class Cat extends Animal {
    @Override
    void makeSound() {
        System.out.println("Meow");
    }
}

public class Main {
    public static void main(String[] args) {
        Animal animal = new Dog();
        animal.makeSound(); // Outputs: Bark

        animal = new Cat();
        animal.makeSound(); // Outputs: Meow
    }
}
```
**Key Points:**
- The method implementation is decided at runtime based on the object type.
- Essential for frameworks like Spring, where bean definitions depend on runtime objects.

## 3. Overriding Static and Private Methods
Static and private methods are not subject to polymorphism as they belong to the class rather than the instance.

#### Interview Scenario:
```java
class Parent {
    static void staticMethod() {
        System.out.println("Parent static method");
    }

    private void privateMethod() {
        System.out.println("Parent private method");
    }
}

class Child extends Parent {
    static void staticMethod() {
        System.out.println("Child static method");
    }

    private void privateMethod() {
        System.out.println("Child private method");
    }
}

public class Main {
    public static void main(String[] args) {
        Parent.staticMethod(); // Parent static method
        Child.staticMethod();  // Child static method
    }
}
```
**Key Points:**
- Static methods are hidden, not overridden.
- Private methods cannot be overridden; they are specific to the class.

## 4. Default Methods in Interfaces
Default methods in interfaces allow backward compatibility and flexibility in providing base implementation.

#### Advanced Example:
```java
interface Loggable {
    default void log(String message) {
        System.out.println("Logging: " + message);
    }
}

class Logger implements Loggable {
    @Override
    public void log(String message) {
        System.out.println("Custom Log: " + message);
    }
}

public class Main {
    public static void main(String[] args) {
        Loggable logger = new Logger();
        logger.log("Hello, World!");
    }
}
```
**Key Points:**
- Default methods allow interfaces to evolve without breaking existing implementations.
- Can be overridden if custom behavior is required.

## 5. Finalize Method and Garbage Collection
The `finalize` method is deprecated in modern Java due to its unpredictability. Use `try-with-resources` or explicit resource management instead.

#### Interview Scenario:
```java
class Resource {
    @Override
    protected void finalize() {
        System.out.println("Finalize method called.");
    }
}

public class Main {
    public static void main(String[] args) {
        Resource resource = new Resource();
        resource = null;
        System.gc(); // Request garbage collection
        System.out.println("End of program.");
    }
}
```
**Key Points:**
- The JVM is not guaranteed to call `finalize`.
- Prefer `AutoCloseable` or `try-with-resources` for resource management.

---

This document now focuses on advanced and tricky aspects of OOP concepts suitable for a 2-year professional. Let me know if further adjustments are required.

Advanced Java Topics: ConcurrentHashMap, TreeMap, and CompareTo Method

This document covers advanced topics in Java, including the use of ConcurrentHashMap, handling hash collisions, internal structures of HashMap, and the workings of TreeMap with the compareTo method.

## 1. ConcurrentHashMap: Parallel Thread Access and Modification

Key Features:

- Designed for concurrent access and modification by multiple threads.

- Provides thread safety without locking the entire map, improving performance.

Example:
```java
import java.util.concurrent.*;

public class Main {
    public static void main(String[] args) {
        ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
        map.put("A", 1);
        map.put("B", 2);

        map.forEach((key, value) -> System.out.println(key + " = " + value));
    }
}
```
## 2. Null Keys and Values in ConcurrentHashMap

Behavior:

- ConcurrentHashMap does not allow null keys or values.

- Throws NullPointerException immediately when attempting to add a null.

Example:
```java
ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();

map.put(null, "Value"); // Throws NullPointerException
map.put("Key", null);   // Throws NullPointerException
```
## 3. Segment Locking (Bucket Locking) in ConcurrentHashMap

Mechanism:

- Uses a segmented or bucket-level locking mechanism.

- Only locks the bucket being accessed, allowing other threads to access other buckets.

- Greatly reduces contention and increases scalability.

Illustration:
```java
// Internally, the map divides data into segments:
ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
map.put("Key1", 10); // Locks one segment
map.put("Key2", 20); // May lock another segment
```
## 4. ConcurrentHashMap vs Hashtable

Advantages of ConcurrentHashMap:

- Uses bucket-level locking instead of locking the entire map.

- Offers better performance in high-concurrency scenarios.

- No performance degradation in multi-threaded environments.

Example:
```java
// Hashtable
Hashtable<String, String> hashtable = new Hashtable<>();
hashtable.put("A", "Value1"); // Locks the entire map

// ConcurrentHashMap
ConcurrentHashMap<String, String> map = new ConcurrentHashMap<>();
map.put("A", "Value1"); // Locks only the relevant bucket
```
## 5. Hash Collisions

Explanation:

- A hash collision occurs when two keys have the same hash code.

- HashMap resolves collisions using a linked list (Java 7) or a balanced tree (Java 8+).

Example:
```java
HashMap<Integer, String> map = new HashMap<>();
map.put(1, "A");
map.put(17, "B"); // Collides with key 1 (if hash function causes it)
```
## 6. Internal Working of HashMap

Structure:

- Uses an array of buckets, where each bucket stores key-value pairs.

- In case of collisions, a linked list is formed in the bucket.

Java 8 Changes:

- When the linked list exceeds a threshold (e.g., 8 elements), it is converted to a balanced tree for faster lookups.

## 7. Understanding TreeMap

Features:

- TreeMap is a sorted map that maintains the natural ordering of its keys.

- Sorting is based on the compareTo method of the keys.

Example:
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        TreeMap<Integer, String> map = new TreeMap<>();
        map.put(3, "C");
        map.put(1, "A");
        map.put(2, "B");

        System.out.println(map); // Output: {1=A, 2=B, 3=C}
    }
}
```
## 8. The compareTo Method

Explanation:

Part of the Comparable interface.

Compares two objects and returns:

- -1 if the current object is less than the other.

- 0 if both objects are equal.

- 1 if the current object is greater.

Example:
```java
class Employee implements Comparable<Employee> {
    private String name;
    private int id;

    public Employee(String name, int id) {
        this.name = name;
        this.id = id;
    }

    @Override
    public int compareTo(Employee other) {
        return Integer.compare(this.id, other.id);
    }

    @Override
    public String toString() {
        return name + " (" + id + ")";
    }
}

public class Main {
    public static void main(String[] args) {
        List<Employee> employees = new ArrayList<>();
        employees.add(new Employee("Alice", 102));
        employees.add(new Employee("Bob", 101));
        employees.add(new Employee("Charlie", 103));

        Collections.sort(employees);
        System.out.println(employees); // Sorted by ID
    }
}
```
This document provides insights into advanced Java topics, focusing on concurrent maps, hash collision handling, and sorted collections. Let me know if you need additional examples or explanations!

